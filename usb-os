#!/bin/bash
# usb-os â€” identify OS on connected USB sticks (safe, read-only)
# Simple edition: ASCII separators, minimal color, no emojis.
set -Eeuo pipefail

usage() {
  cat <<USAGE
Usage: usb-os [-l] [-d /dev/sdX] [--plain]
  -l              List USB disks/partitions only (no probing)
  -d /dev/sdX     Probe a single USB disk (e.g., /dev/sdb)
  -h              Help
  --plain         Disable colors (same as NO_COLOR=1)
USAGE
}

# ---------- minimal color ----------
supports_color() { [ -t 1 ] && command -v tput >/dev/null 2>&1 && [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; }
PLAIN=0; for a in "$@"; do [[ "$a" == "--plain" ]] && PLAIN=1 && break; done
if supports_color && [ -z "${NO_COLOR:-}" ] && [ $PLAIN -eq 0 ]; then
  B=$(tput bold); R=$(tput sgr0)
  DIM=$(tput setaf 8)  # grey
  CY=$(tput setaf 6)   # cyan
  GR=$(tput setaf 2)   # green
  YL=$(tput setaf 3)   # yellow
else
  B=""; R=""; DIM=""; CY=""; GR=""; YL=""
fi

hr(){ printf "%s\n" "----------------------------------------------------------------"; }

# ---------- helpers ----------
TMP=""
cleanup(){ [[ -n "$TMP" ]] && { umount -q "$TMP/.squash" 2>/dev/null || true; umount -q "$TMP/.iso/.squash" 2>/dev/null || true; umount -q "$TMP/.iso" 2>/dev/null || true; umount -q "$TMP" 2>/dev/null || true; rmdir "$TMP" 2>/dev/null || true; }; }
trap cleanup EXIT
mkmt(){ TMP="$(mktemp -d /mnt/usb_probe.XXXX)"; }

dev_base(){ local d; d="$(readlink -f "$1")"; [[ "$d" =~ ^/dev/ ]] || { echo ""; return; }; echo "${d}" | sed -E 's/p?[0-9]+$//'; }

skip_set_build(){ declare -gA SKIP=(); local src base; for mp in / /boot /boot/firmware; do src="$(findmnt -no SOURCE -T "$mp" 2>/dev/null || true)"; [[ -z "$src" ]] && continue; base="$(dev_base "$src")"; [[ -n "$base" ]] && SKIP["$base"]=1; done; }

usb_disks(){ lsblk -nrpo NAME,TRAN,TYPE | awk '$2=="usb" && $3=="disk"{print $1}'; }

fs_of(){ blkid -s TYPE -o value "$1" 2>/dev/null || lsblk -nro FSTYPE "$1" 2>/dev/null; }
label_decode(){ local s="$1"; [ -n "$s" ] && printf '%b' "$s" | tr -d '\r' || true; }
lbl_of(){ local L; L="$(blkid -s LABEL -o value "$1" 2>/dev/null || lsblk -nro LABEL "$1" 2>/dev/null)"; label_decode "$L"; }
size_of(){ lsblk -nro SIZE "$1" 2>/dev/null; }
type_of(){ lsblk -nro TYPE "$1" 2>/dev/null; }

# ---------- list view ----------
list_usb() {
  printf "${B}${CY}usb-os${R}  (list)\n"
  hr
  for d in $(usb_disks); do
    if [[ -n "${SKIP["$d"]+x}" ]]; then
      printf "%s  %s (host system disk, skipped)%s\n" "$DIM" "$d" "$R"
      continue
    fi
    local size model; size="$(size_of "$d")"; model="$(lsblk -ndo MODEL "$d" 2>/dev/null | sed 's/^ *//;s/ *$//')"
    printf "%s  %s%s  %s(%s, %s)%s\n" "$B" "$d" "$R" "$DIM" "${model:-unknown}" "${size:-unknown}" "$R"
    printf "    %-14s %-6s %-5s %-8s %s\n" "NODE" "SIZE" "TYPE" "FS" "LABEL"
    while read -r part; do
      [ -b "$part" ] || continue
      printf "    %-14s %-6s %-5s %-8s %s\n" \
        "$part" "$(size_of "$part")" "$(type_of "$part")" "$(fs_of "$part")" "$(lbl_of "$part")"
    done < <(lsblk -nrpo NAME,TYPE "$d" | awk '$2=="part"{print $1}')
    hr
  done
}

# ---------- probing ----------
probe_mount(){
  local m="$1" found=0
  if [[ -f "$m/etc/os-release" ]]; then . "$m/etc/os-release"; printf "  %sInstalled:%s %s (%s)\n" "$GR" "$R" "$PRETTY_NAME" "${VERSION_CODENAME:-n/a}"; found=1; fi
  if [[ -f "$m/usr/lib/os-release" && ! -f "$m/etc/os-release" ]]; then . "$m/usr/lib/os-release"; printf "  %sInstalled:%s %s (%s)\n" "$GR" "$R" "$PRETTY_NAME" "${VERSION_CODENAME:-n/a}"; found=1; fi
  if [[ -f "$m/etc/lsb-release" ]]; then . "$m/etc/lsb-release"; printf "  %sInstalled (lsb):%s %s\n" "$GR" "$R" "${DISTRIB_DESCRIPTION:-$DISTRIB_ID $DISTRIB_RELEASE}"; found=1; fi
  if [[ -f "$m/etc/issue" ]]; then printf "  %sIssue:%s %s\n" "$GR" "$R" "$(head -1 "$m/etc/issue")"; found=1; fi

  [[ -f "$m/.disk/info" ]] && printf "  %sLive ISO:%s %s\n" "$YL" "$R" "$(head -1 "$m/.disk/info")" && found=1
  for s in casper/filesystem.squashfs live/filesystem.squashfs; do
    if [[ -f "$m/$s" ]]; then
      mkdir -p "$m/.squash"
      if mount -o ro,loop "$m/$s" "$m/.squash" 2>/dev/null; then
        local pn cn
        pn="$(grep -E '^PRETTY_NAME=' "$m/.squash/etc/os-release" 2>/dev/null | cut -d= -f2- | tr -d '"' )"
        cn="$(grep -E '^VERSION_CODENAME=' "$m/.squash/etc/os-release" 2>/dev/null | cut -d= -f2- | tr -d '"')"
        [[ -n "$pn$cn" ]] && printf "    squashfs: %s %s\n" "$pn" "${cn:+($cn)}" && found=1
        umount "$m/.squash" 2>/dev/null || true
      fi
    fi
  done

  [[ -f "$m/config.txt" ]] && printf "  %sBoot:%s Raspberry Pi firmware-style\n" "$GR" "$R" && found=1
  [[ -f "$m/EFI/BOOT/BOOTx64.EFI" ]] && printf "  %sBoot:%s x86_64 PC-style EFI\n" "$GR" "$R" && found=1
  return $(( found ? 0 : 1 ))
}

probe_disk(){
  local disk="$1" found=0
  local tr ty; read -r tr ty < <(lsblk -nrpo TRAN,TYPE "$disk" | head -n1)
  [[ "$tr" != "usb" || "$ty" != "disk" ]] && { printf "%s (not a USB disk, skipped)\n" "$disk"; return 0; }

  if [[ -n "${SKIP["$disk"]+x}" ]]; then
    hr; printf "%s%s%s\n" "$B" "$disk" "$R"; printf "  %sThis appears to be the host system disk. Skipping.%s\n" "$DIM" "$R"; return 0
  fi

  hr
  local size model; size="$(size_of "$disk")"; model="$(lsblk -ndo MODEL "$disk" 2>/dev/null | sed 's/^ *//;s/ *$//')"
  printf "%s%s%s  %s(%s, %s)%s\n" "$B" "$disk" "$R" "$DIM" "${model:-unknown}" "${size:-unknown}" "$R"
  printf "  %-14s %-6s %-5s %-8s %s\n" "NODE" "SIZE" "TYPE" "FS" "LABEL"
  while read -r part; do
    [ -b "$part" ] || continue
    printf "  %-14s %-6s %-5s %-8s %s\n" \
      "$part" "$(size_of "$part")" "$(type_of "$part")" "$(fs_of "$part")" "$(lbl_of "$part")"
  done < <(lsblk -nrpo NAME,TYPE "$disk" | awk '$2=="part"{print $1}')

  mkmt
  while read -r part; do
    [[ -b "$part" ]] || continue
    if mount -o ro,nosuid,nodev,noexec "$part" "$TMP" 2>/dev/null; then
      probe_mount "$TMP" && found=1 || true
      umount "$TMP" 2>/dev/null || true
    fi
  done < <(lsblk -nrpo NAME,TYPE "$disk" | awk '$2=="part"{print $1}')

  if (( ! found )); then
    if mount -o ro,nosuid,nodev,noexec "$disk" "$TMP" 2>/dev/null; then
      probe_mount "$TMP" && found=1 || true
      umount "$TMP" 2>/dev/null || true
    fi
  fi
  (( found )) || printf "  %sNo OS info found (data drive or non-standard layout).%s\n" "$DIM" "$R"
}

# ---------- main ----------
d_arg=""; l_flag=0; args=()
for arg in "$@"; do case "$arg" in --plain) : ;; *) args+=("$arg");; esac; done; set -- "${args[@]}"
while getopts ":d:lh" opt; do
  case "$opt" in
    d) d_arg="$OPTARG" ;; l) l_flag=1 ;; h) usage; exit 0 ;;
    \?) echo "Unknown option: -$OPTARG" >&2; usage; exit 2 ;;
    :)  echo "Option -$OPTARG requires an argument" >&2; usage; exit 2 ;;
  esac
done

skip_set_build
printf "${B}${CY}usb-os${R}\n"
hr

if (( l_flag )); then list_usb; exit 0; fi
if [[ -n "$d_arg" ]]; then probe_disk "$d_arg"; exit 0; fi
for d in $(usb_disks); do probe_disk "$d"; done
hr
